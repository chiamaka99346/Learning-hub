terraform {
  required_version = ">= 1.6.0"
  required_providers {
    aws   = { source = "hashicorp/aws", version = ">= 5.0" }
    tls   = { source = "hashicorp/tls", version = "~> 4.0" }
    local = { source = "hashicorp/local", version = "~> 2.5" }
  }

  # Optional: remote backend
  # backend "s3" {
  #   bucket         = "YOUR_TFSTATE_BUCKET"
  #   key            = "jenkins/terraform.tfstate"
  #   region         = "us-east-1"
  #   dynamodb_table = "YOUR_TF_LOCK_TABLE"
  #   encrypt        = true
  # }
}

provider "aws" {
  region = var.aws_region
}

########################################
# Variables
########################################
variable "aws_region"       { type = string, default = "us-east-1" }
variable "instance_type"    { type = string, default = "t3.small" }
variable "ssh_cidr_blocks"  { type = list(string), default = ["0.0.0.0/0"] }
variable "ami_id"           { type = string, default = "" } # optional override

# optional â€” used by your previous script; safe defaults
variable "install_editors"  { type = bool,   default = false }
variable "github_repo_url"  { type = string, default = "" }
variable "github_repo_branch" { type = string, default = "main" }
variable "repo_clone_path"  { type = string, default = "/opt/app" }

########################################
# Key Pair (generated by Terraform)
########################################
locals {
  key_name = "jenkins-prod"
  key_dir  = "${path.module}/secrets"
}

resource "tls_private_key" "jenkins" {
  algorithm = "RSA"
  rsa_bits  = 4096
}

resource "local_file" "private_key" {
  filename        = "${local.key_dir}/${local.key_name}.pem"
  content         = tls_private_key.jenkins.private_key_pem
  file_permission = "0600"
}

resource "aws_key_pair" "jenkins" {
  key_name   = local.key_name
  public_key = tls_private_key.jenkins.public_key_openssh
}

########################################
# Networking (default VPC)
########################################
data "aws_vpc" "default" { default = true }

data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}

########################################
# Security Group
########################################
resource "aws_security_group" "jenkins_sg" {
  name        = "jenkins-sg"
  description = "Allow SSH, Jenkins UI, and app HTTP"
  vpc_id      = data.aws_vpc.default.id

  ingress {
    description = "SSH"
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = var.ssh_cidr_blocks
  }

  ingress {
    description = "Jenkins UI"
    from_port   = 8080
    to_port     = 8080
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    description = "App HTTP"
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  # If you actually need inbound JNLP agents, uncomment this and lock it down
  # ingress {
  #   description = "Jenkins inbound agents"
  #   from_port   = 50000
  #   to_port     = 50000
  #   protocol    = "tcp"
  #   cidr_blocks = var.ssh_cidr_blocks
  # }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

########################################
# AMI
########################################
# Use provided AMI if set; otherwise Amazon Linux 2023 x86_64
data "aws_ami" "al2023" {
  owners      = ["137112412989"] # Amazon
  most_recent = true
  filter { name = "name",         values = ["al2023-ami-2023*"] }
  filter { name = "architecture", values = ["x86_64"] }
}

locals {
  chosen_ami = var.ami_id != "" ? var.ami_id : data.aws_ami.al2023.id
}

########################################
# User Data (Jenkins + Docker)
########################################
locals {
  user_data = <<-EOF
    #!/usr/bin/env bash
    set -euxo pipefail

    # AL2023 uses dnf
    dnf -y update || true
    dnf -y install java-17-amazon-corretto git docker || yum -y install java-17-amazon-corretto git docker || true

    # Jenkins repo
    rpm --import https://pkg.jenkins.io/redhat/jenkins.io-2023.key
    cat >/etc/yum.repos.d/jenkins.repo <<'REPO'
    [jenkins]
    name=Jenkins-stable
    baseurl=https://pkg.jenkins.io/redhat-stable
    gpgcheck=1
    gpgkey=https://pkg.jenkins.io/redhat/jenkins.io-2023.key
    REPO

    dnf -y install jenkins || yum -y install jenkins

    systemctl enable docker jenkins
    systemctl start docker
    usermod -aG docker jenkins
    systemctl restart jenkins

    # Optional editors
    if [ "${var.install_editors}" = "true" ]; then
      dnf -y install vim-enhanced nano || yum -y install vim-enhanced nano || true
    fi

    # Optional repo clone
    if [ -n "${var.github_repo_url}" ]; then
      mkdir -p ${var.repo_clone_path}
      cd ${var.repo_clone_path}
      git init
      git remote add origin ${var.github_repo_url}
      git fetch --depth 1 origin ${var.github_repo_branch}
      git checkout -b ${var.github_repo_branch} FETCH_HEAD
    fi
  EOF
}

########################################
# EC2 Instance
########################################
resource "aws_instance" "jenkins_ec2" {
  ami                         = local.chosen_ami
  instance_type               = var.instance_type
  subnet_id                   = data.aws_subnets.default.ids[0]
  vpc_security_group_ids      = [aws_security_group.jenkins_sg.id]
  key_name                    = aws_key_pair.jenkins.key_name
  associate_public_ip_address = true
  user_data                   = local.user_data

  tags = { Name = "Jenkins-Server" }
}

########################################
# Outputs (consumed by Jenkinsfile)
########################################
output "public_ip" {
  value = aws_instance.jenkins_ec2.public_ip
}

output "private_key_path" {
  value       = local_file.private_key.filename
  description = "Where Terraform saved the private key"
}

output "key_name" {
  value = aws_key_pair.jenkins.key_name
}